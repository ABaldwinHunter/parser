<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: README
  
    &mdash; Documentation by YARD 0.8.7.4
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!file.README.html";
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'><h1 id="parser">Parser</h1>

<p><a href="http://badge.fury.io/rb/parser"><img src="https://badge.fury.io/rb/parser.png" alt="Gem Version" /></a>
<a href="https://travis-ci.org/whitequark/parser"><img src="https://travis-ci.org/whitequark/parser.png?branch=master" alt="Build Status" /></a>
<a href="https://codeclimate.com/github/whitequark/parser"><img src="https://codeclimate.com/github/whitequark/parser.png" alt="Code Climate" /></a>
<a href="https://coveralls.io/r/whitequark/parser"><img src="https://coveralls.io/repos/whitequark/parser/badge.png?branch=master" alt="Coverage Status" /></a></p>

<p><em>Parser</em> is a production-ready Ruby parser written in pure Ruby. It performs on
par or better than Ripper, Melbourne, JRubyParser or ruby_parser.</p>

<p>You can also use <a href="https://github.com/mbj/unparser">unparser</a> to produce
equivalent source code from Parser’s ASTs.</p>

<p>Sponsored by <a href="http://evilmartians.com">Evil Martians</a>.</p>

<h2 id="installation">Installation</h2>

<pre class="code ruby"><code class="ruby">$ gem install parser
</code></pre>

<h2 id="usage">Usage</h2>

<p>Parse a chunk of code:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>parser/current</span><span class='tstring_end'>&#39;</span></span>

<span class='id identifier rubyid_p'>p</span> <span class='const'>Parser</span><span class='op'>::</span><span class='const'>CurrentRuby</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>2 + 2</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
<span class='comment'># (send
</span><span class='comment'>#   (int 2) :+
</span><span class='comment'>#   (int 2))
</span></code></pre>

<p>Access the AST’s source map:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='const'>Parser</span><span class='op'>::</span><span class='const'>CurrentRuby</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>2 + 2</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_loc'>loc</span>
<span class='comment'># #&lt;Parser::Source::Map::Send:0x007fe5a1ac2388
</span><span class='comment'>#   @dot=nil,
</span><span class='comment'>#   @begin=nil,
</span><span class='comment'>#   @end=nil,
</span><span class='comment'>#   @selector=#&lt;Source::Range (string) 2...3&gt;,
</span><span class='comment'>#   @expression=#&lt;Source::Range (string) 0...5&gt;&gt;
</span>
<span class='id identifier rubyid_p'>p</span> <span class='const'>Parser</span><span class='op'>::</span><span class='const'>CurrentRuby</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>2 + 2</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_loc'>loc</span><span class='period'>.</span><span class='id identifier rubyid_selector'>selector</span><span class='period'>.</span><span class='id identifier rubyid_source'>source</span>
<span class='comment'># &quot;+&quot;
</span></code></pre>

<p>Parse a chunk of code and display all diagnostics:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_parser'>parser</span> <span class='op'>=</span> <span class='const'>Parser</span><span class='op'>::</span><span class='const'>CurrentRuby</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_diagnostics'>diagnostics</span><span class='period'>.</span><span class='id identifier rubyid_consumer'>consumer</span> <span class='op'>=</span> <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_diag'>diag</span><span class='op'>|</span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_diag'>diag</span><span class='period'>.</span><span class='id identifier rubyid_render'>render</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'>Parser</span><span class='op'>::</span><span class='const'>Source</span><span class='op'>::</span><span class='const'>Buffer</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>(string)</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_buffer'>buffer</span><span class='period'>.</span><span class='id identifier rubyid_source'>source</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo *bar</span><span class='tstring_end'>&quot;</span></span>

<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='id identifier rubyid_buffer'>buffer</span><span class='rparen'>)</span>
<span class='comment'># (string):1:5: warning: `*&#39; interpreted as argument prefix
</span><span class='comment'># foo *bar
</span><span class='comment'>#     ^
</span><span class='comment'># (send nil :foo
</span><span class='comment'>#   (splat
</span><span class='comment'>#     (send nil :bar)))
</span></code></pre>

<p>If you reuse the same parser object for multiple <code>#parse</code> runs, you need to
<code>#reset</code> it.</p>

<p>You can also use the <code>ruby-parse</code> utility (it’s bundled with the gem) to play
with Parser:</p>

<pre class="code ruby"><code class="ruby">$ ruby-parse -L -e &quot;2+2&quot;
(send
  (int 2) :+
  (int 2))
2+2
 ~ selector
~~~ expression
(int 2)
2+2
~ expression
(int 2)
2+2

$ ruby-parse -E -e &quot;2+2&quot;
2+2
^ tINTEGER 2                                    expr_end     [0 &lt;= cond] [0 &lt;= cmdarg]
2+2
 ^ tPLUS &quot;+&quot;                                    expr_beg     [0 &lt;= cond] [0 &lt;= cmdarg]
2+2
  ^ tINTEGER 2                                  expr_end     [0 &lt;= cond] [0 &lt;= cmdarg]
2+2
  ^ false &quot;$eof&quot;                                expr_end     [0 &lt;= cond] [0 &lt;= cmdarg]
(send
  (int 2) :+
  (int 2))
</code></pre>

<h2 id="features">Features</h2>

<ul>
  <li>Precise source location reporting.</li>
  <li><a href="doc/AST_FORMAT.md">Documented</a> AST format which is convenient to work with.</li>
  <li>A simple interface and a powerful, tweakable one.</li>
  <li>Parses 1.8, 1.9, 2.0, 2.1 and 2.2 (preliminary) syntax with backwards-compatible
AST formats.</li>
  <li><a href="http://whitequark.org/blog/2013/04/26/lets-play-with-ruby-code/">Rewriting</a> support.</li>
  <li>Parsing error recovery.</li>
  <li>Improved <a href="http://clang.llvm.org/diagnostics.html">clang-like</a> diagnostic messages with location information.</li>
  <li>Written in pure Ruby, runs on MRI 1.8.7 or &gt;=1.9.2, JRuby and Rubinius in 1.8
and 1.9 mode.</li>
  <li>Only two runtime dependencies: the gems <a href="http://rubygems.org/gems/ast">ast</a> and <a href="http://rubygems.org/gems/slop">slop</a>.</li>
  <li><a href="http://whitequark.org/blog/2013/04/01/ruby-hacking-guide-ch-11-finite-state-lexer/">Insane</a> Ruby lexer rewritten from scratch in Ragel.</li>
  <li>100% test coverage for Bison grammars (except error recovery).</li>
  <li>Readable, commented source code.</li>
</ul>

<h2 id="documentation">Documentation</h2>

<p>Documentation for parser is available online on
<a href="http://rdoc.info/github/whitequark/parser">rdoc.info</a>.</p>

<h3 id="node-names">Node names</h3>

<p>Several Parser nodes seem to be confusing enough to warrant a dedicated README section.</p>

<h4 id="block">(block)</h4>

<p>The <code>(block)</code> node passes a Ruby block, that is, a closure, to a method call represented by its first child, a <code>(send)</code>, <code>(super)</code> or <code>(zsuper)</code> node. To demonstrate:</p>

<p><code>
$ ruby-parse -e 'foo { |x| x + 2 }'
(block
  (send nil :foo)
  (args
    (arg :x))
  (send
    (lvar :x) :+
    (int 2)))
</code></p>

<h4 id="begin-and-kwbegin">(begin) and (kwbegin)</h4>

<p><strong>TL;DR: Unless you perform rewriting, treat <code>(begin)</code> and <code>(kwbegin)</code> as the same node type.</strong></p>

<p>Both <code>(begin)</code> and <code>(kwbegin)</code> nodes represent compound statements, that is, several expressions which are executed sequentally and the value of the last one is the value of entire compound statement. They may take several forms in the source code:</p>

<ul>
  <li><code>foo; bar</code>: without delimiters</li>
  <li><code>(foo; bar)</code>: parenthesized</li>
  <li><code>begin foo; bar; end</code>: grouped with <code>begin</code> keyword</li>
  <li><code>def x; foo; bar; end</code>: grouped inside a method definition</li>
</ul>

<p>and so on.</p>

<p><code>
$ ruby-parse -e '(foo; bar)'
(begin
  (send nil :foo)
  (send nil :bar))
$ ruby-parse -e 'def x; foo; bar end'
(def :x
  (args)
  (begin
    (send nil :foo)
    (send nil :bar)))
</code></p>

<p>Note that, despite its name, <code>kwbegin</code> node only has tangential relation to the <code>begin</code> keyword. Normally, Parser AST is semantic, that is, if two constructs look differently but behave identically, they get parsed to the same node. However, there exists a peculiar construct called post-loop in Ruby:</p>

<p><code>
begin
  body
end while condition
</code></p>

<p>This specific syntactic construct, that is, keyword <code>begin..end</code> block followed by a postfix <code>while</code>, <a href="http://rosettacode.org/wiki/Loops/Do-while#Ruby">behaves</a> very unlike other similar constructs, e.g. <code>(body) while condition</code>. While the body itself is wrapped into a <code>while-post</code> node, Parser also supports rewriting, and in that context it is important to not accidentally convert one kind of loop into another.</p>

<p><code>
$ ruby-parse -e 'begin foo end while cond'
(while-post
  (send nil :cond)
  (kwbegin
    (send nil :foo)))
$ ruby-parse -e 'foo while cond'
(while
  (send nil :cond)
  (send nil :foo))
$ ruby-parse -e '(foo) while cond'
(while
  (send nil :cond)
  (begin
    (send nil :foo)))
</code></p>

<p>(Parser also needs the <code>(kwbegin)</code> node type internally, and it is highly problematic to map it back to <code>(begin)</code>.)</p>

<h2 id="known-issues">Known issues</h2>

<p>Adding support for the following Ruby MRI features in Parser would needlessly complicate it, and as they all are very specific and rarely occuring corner cases, this is not done.</p>

<p>Parser has been extensively tested; in particular, it parses almost entire <a href="http://rubygems.org">Rubygems</a> corpus. For every issue, a breakdown of affected gems is offered.</p>

<h3 id="void-value-expressions">Void value expressions</h3>

<p>Ruby MRI prohibits so-called “void value expressions”. For a description
of what a void value expression is, see <a href="https://gist.github.com/JoshCheek/5625007">this
gist</a> and <a href="https://github.com/whitequark/parser/issues/72">this Parser
issue</a>.</p>

<p>It is unknown whether any gems are affected by this issue.</p>

<h3 id="invalid-characters-inside-comments">Invalid characters inside comments</h3>

<p>Ruby MRI permits arbitrary non-7-bit characters to appear in comments regardless of source encoding.</p>

<p>As of 2013-07-25, there are about 180 affected gems.</p>

<h3 id="u-escape-in-18-mode">\u escape in 1.8 mode</h3>

<p>Ruby MRI 1.8 permits to specify a bare <code>\u</code> escape sequence in a string; it treats it like <code>u</code>. Ruby MRI 1.9 and later treat <code>\u</code> as a prefix for Unicode escape sequence and do not allow it to appear bare. Parser follows 1.9+ behavior.</p>

<p>As of 2013-07-25, affected gems are: activerdf, activerdf_net7, fastreader, gkellog-reddy.</p>

<h3 id="invalid-unicode-escape-sequences">Invalid Unicode escape sequences</h3>

<p>Ruby MRI 1.9+ permits to specify invalid Unicode codepoints in Unicode escape sequences, such as <code>\u{d800}</code>.</p>

<p>As of 2013-07-25, affected gems are: aws_cloud_search.</p>

<h3 id="dollar-dash">Dollar-dash</h3>

<p>(This one is so obscure I couldn’t even think of a saner name for this issue.) Pre-2.1 Ruby allows
to specify a global variable named <code>$-</code>. Ruby 2.1 and later treat it as a syntax error. Parser
follows 2.1 behavior.</p>

<p>No known code is affected by this issue.</p>

<h2 id="contributors">Contributors</h2>

<ul>
  <li>Peter Zotov (<a href="https://github.com/whitequark">whitequark</a>)</li>
  <li>Markus Schirp (<a href="https://github.com/mbj">mbj</a>)</li>
  <li>Yorick Peterse (<a href="https://github.com/yorickpeterse">yorickpeterse</a>)</li>
  <li>Magnus Holm (<a href="https://github.com/judofyr">judofyr</a>)</li>
  <li>Bozhidar Batsov (<a href="https://github.com/bbatsov">bbatsov</a>)</li>
</ul>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>The lexer testsuite is derived from
<a href="http://github.com/seattlerb/ruby_parser">ruby_parser</a>.</p>

<p>The Bison parser rules are derived from <a href="http://github.com/ruby/ruby">Ruby MRI</a>
parse.y.</p>

<h2 id="contributing">Contributing</h2>

<ol>
  <li>Make sure you have <a href="http://www.complang.org/ragel/">Ragel ~&gt; 6.7</a> installed</li>
  <li>Fork it</li>
  <li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li>
  <li>Commit your changes (<code>git commit -am 'Add some feature'</code>)</li>
  <li>Push to the branch (<code>git push origin my-new-feature</code>)</li>
  <li>Create new Pull Request</li>
</ol>
</div></div>

    <div id="footer">
  Generated on Mon Jun 16 19:42:15 2014 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.4 (ruby-2.1.1).
</div>

  </body>
</html>